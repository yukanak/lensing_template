# class containing functions that get to the
# B template calculation, bias estimate,
# and uncertainties.
#
# previous iterations at repos/btpl_ngfg, repos/202205_curv_lenstpl
#
# lowpass5000 alm for input CMB map generated by
# spt3g_software/scratch/wlwu/simulations/lowpass_inputsims_xover.py

import sys, os
import numpy as np
sys.path.insert(0, "/home/users/yukanaka/miniconda3/envs/tora_py3/lib/python3.10/site-packages/") #newer scipy version
import h5py
from astropy.io import fits
from jax.experimental.sparse import BCOO
from scipy.sparse import csc_array
import healpy as hp
import yaml
sys.path.insert(0,'/home/users/yukanaka/healqest/healqest/src/')
import healqest_utils as hutils
#import weights
import qest
import matplotlib.pyplot as plt


def alm2grid(alm, realpart=False, magnitude=False):
    """
    Convert Healpix alm array to 2d grid
    """

    lmax = hp.Alm.getlmax(alm.shape[0])
    ell,emm = hp.Alm.getlm(lmax)
    if magnitude:
        alm = np.abs(alm)
    elif realpart:
        alm = alm.real
    a=np.zeros((lmax+1,lmax+1), dtype=alm.dtype)
    idx  = 0
    idxf = 0
    for i in range(0,lmax+1):
        idxf = idx + lmax + 1 -i
        a[i,i:]=alm[idx:idx+(lmax+1-i)]
        idx=idxf
    return a


def grid2alm(grid):
    """
    Convert 2d grid back to Healpix alm
    """
    lmax = grid.shape[0]-1
    alm=np.zeros(hp.Alm.getsize(lmax),dtype=np.complex_)
    for l in range(0,lmax+1):
        for m in range(0,l+1):
            # l,m
            alm[hp.Alm.getidx(lmax,l,m)]=grid[m,l]
    return alm


def get_lmmask(lmax, lmin=0, mmin=0, lmax_sub=None):
    lmmask = np.zeros([lmax+1, lmax+1])
    for l in range(0,lmax+1):
        lmmask[0:l+1, l] = 1.0

    lmmask[:mmin,:] = 0
    lmmask[:,:lmin] = 0

    if lmax_sub is not None:
        lmmask[:, lmax_sub+1:] = 0

    return lmmask

def safe_inv(arr):
    arr = arr.astype(float)
    arr[arr != 0] = 1/arr[arr !=0]
    return arr

def rebincl(ell,cl, bb):
    #bb   = np.linspace(minell,maxell,Nbins+1)
    Nbins=len(bb)-1
    ll   = (bb[:-1]).astype(np.int_)
    uu   = (bb[1:]).astype(np.int_)
    ret  = np.zeros(Nbins)
    retl = np.zeros(Nbins)
    err  = np.zeros(Nbins)
    for i in range(0,Nbins):
        idx     = np.where((ell>ll[i]) & (ell<=uu[i]))[0]
        ret[i]  = np.mean(cl[idx])
        retl[i] = np.mean(ell[idx])
        err[i]  = np.std(cl[idx])
    return retl,ret

def get_bb_bpwf_binned_bb(): #theory_clbb):
    # output BPWF matrix to be applied to input Dl to get binned Dl

    import scipy.io as sio
    tmp = sio.loadmat("/lcrc/project/SPT3G/analysis/btemplates_19-20/b3sptmask_bpwf/xxxx_B3_2018_filtl3_weight4_gs_ring_dp1100_jack01_matrix_directbpwf.mat")
    bpwf = tmp['bpwf']['Cs_l'][0][0][:,:,3]  #idx=3 for BB
    #shape (998, 17)
    lmax, nbin = bpwf.shape

    dlbb = np.loadtxt("/home/ac.wlwu/repos/spt3g_software/simulations/data/camb/planck18_TTEEEE_lowl_lowE_lensing_highacc/planck2018_base_plikHM_TTTEEE_lowl_lowE_lensing_lensedCls.dat")[:,3]
    dlbb = np.concatenate([[0],dlbb[:lmax-1]])

    ells        = np.arange(1, lmax+1)
    bpwfnorm    = bpwf / np.sum(bpwf.T, axis=1) #so that each bpwf bin sum to 1
    binned_ell  = bpwfnorm.T@ells #probably not quite right
    binned_dlbb = bpwf.T@dlbb

    return bpwf, binned_ell, binned_dlbb

def load_b3_beam():
    # B_ell in map units
    # start at ell=0
    import astropy.io.fits as afits
    hudl = afits.open("/lcrc/project/SPT3G/analysis/btemplates_19-20/beams/beamfile_20180206_polycorr_sum_100.fits")
    tmp = hudl[1].data
    beam = tmp['TEMP AND POL']

    return beam

def load_compsep_beam(lmax=1788):
    # compsep maps are smoothed by a 20' FWHM beam;
    # before applying obsmat, rebeam compsep maps by b3beam/20'arcmin-beam
    #lmax=1788 matches the b3 beam

    fwhm_rad = 20 * np.pi/180/60
    bl = hp.gauss_beam( fwhm_rad, lmax=lmax)

    return bl

class btemplate():

    def __init__(self, yaml_file, bk_yaml=None):

        #load btmpl yaml
        bconfig     = yaml.safe_load(open(yaml_file, "rb"))
        self.lmax_e = bconfig['ep_ells']['lmax_e']
        self.lmax_p = bconfig['ep_ells']['lmax_p']
        self.lmax_b = bconfig['ep_ells']['lmax_b']
        self.lmin_e = bconfig['ep_ells']['lmin_e']
        self.lmin_p = bconfig['ep_ells']['lmin_p']
        self.mmin_e = bconfig['ep_ells']['mmin_e']
        #elm and plm has to be same size for qe
        #set lmax for elm, plm with filter
        self.lmax   = max(self.lmax_e, self.lmax_p)

        self.outdir     = bconfig['outputs']['dir']
        self.btpl_fname = bconfig['outputs']['btpl_fname']
        self.btpl_spec_fname = bconfig['outputs']['btpl_spec_fname']
        self.btpl_pure_spec_fname = bconfig['outputs']['btpl_pure_spec_fname']

        self.san0fname  = bconfig['phi']['san0fname']
        self.rdn0fname  = bconfig['phi']['rdn0fname']


        #load phi yaml
        pconfig     = yaml.safe_load(open(bconfig['phi_yaml'], "rb"))
        self.maskfname = pconfig['pspec']['mask_boundary']  ##TODO: test different masks

        #load cinve yaml
        econfig     = yaml.safe_load(open(bconfig['e_yaml'], "rb"))

        self.dir_cinve  = econfig['outdir']+bconfig['cinve']['dir_cinve']

        #phi map, response, glmstacks
        self.dir_p      = bconfig['phi']['dir_phi']
        self.dir_resp   = bconfig['phi']['dir_resp']
        self.qe         = bconfig['phi']['qe']

        self.phi2kap    = lambda l: l*(l+1)/2.0
        self.ls         = np.arange(self.lmax+1).astype(float)

        ell,sltt,slee,slbb,slte = hutils.get_lensedcls(pconfig['cls']['file_lcmb']  , lmax=self.lmax)
        _,_,_,_,_,slpp,_ ,_     = hutils.get_unlensedcls(pconfig['cls']['file_ucmb'], lmax=self.lmax)

        self.clkk = self.phi2kap(self.ls)**2 * slpp
        self.clee = slee

        self.nside = 2048

        self.qeconfig={'lensrec':{
        'cltype': 'lcmb',
        'Lmax' : self.lmax_b,  #b lmax
        'lmaxT': self.lmax,  #e, phi lmax
        'lmaxP': self.lmax,  #e, phi lmax
        'nside': self.nside
            }}
        cls = {}
        self.qecls = hutils.add_clsdict(cls,'lcmb',sltt,slee,slbb,clte=slte)

        #BK yaml (obs mat; pure mat)
        if bk_yaml is not None:
            bkconfig = yaml.safe_load(open(bk_yaml, "rb"))
            self.obsmatfname = bkconfig['obsmat']['dir']+bkconfig['obsmat']['fname']
            self.purmatfname = bkconfig['purmat']['dir']+bkconfig['purmat']['fname']
            self.puremask    = bkconfig['purmat']['mask']



    def get_response(self, qe):
        resp = np.load(self.dir_resp%qe+"respavg%s_nops.npz"%qe)['resp']
        return resp[:self.lmax+1]

    def get_meanfield(self, idx, plm, qe):
        #if self.mffname == None:
        #    return 0
        plmstack   = np.load(self.dir_p%qe+"glmstack%s_xx.npz"%qe)
        # check if idx in mf sum
        idx0 = np.arange(1,plmstack['nsim']+1)
        if idx in idx0:
            mf = (plmstack['gmfxx'] - plm)/(plmstack['nsim']-1)
        else:
            mf = plmstack['gmfxx']/plmstack['nsim']

        mfl  = hutils.reduce_lmax(mf, lmax=self.lmax)
        return mfl

    def get_debiased_klm(self, idx):
        #the saved "plm_*" files are NOT already klms
        if self.qe=="PP":
            qetypes=['EE','EB','BE']
        elif self.qe=="qPP":
            qetypes=['EE','EB','EB']
        elif self.qe=="GMV":
            qetypes=['GMVTTEETE','GMVTBEB']
        elif self.qe=="GMVbhTTprf":
            qetypes=['GMVTTEETEbhTTprf','GMVTBEB']
        else:
            qetypes=[self.qe]

        v=0.5*self.ls*(self.ls+1)
        kout    = 0
        respout = 0

        for qe in qetypes:
            plm  = np.load(self.dir_p%qe+"plm%s_%ia_%ia.npz"%(qe,idx,idx))['glm']
            mf   = self.get_meanfield(idx, plm, qe)
            plm  = hutils.reduce_lmax(plm, lmax=self.lmax)
            klm  = plm - mf
            klm = hp.almxfl(klm,v)
            kout    += klm

            resp = self.get_response(qe)
            respout += resp

        return hp.almxfl(kout, safe_inv(respout))

    def get_cinv_elm(self, idx):
        cinvelm =  hp.read_alm(self.dir_cinve+"sim_%04d_elm.fits"%idx)
        return hutils.reduce_lmax(cinvelm, lmax=self.lmax)

    def get_kap_filt(self, idx):

        if self.san0fname == None:
            if self.qe=="PP":
                qetypes=['EE','EB','BE']
            else:
                qetypes=[self.qe]
            respall = 0
            for qe in qetypes:
                resp = self.get_response(qe)
                respall += resp
            n0   = 1/respall[:self.lmax+1]
        elif idx==0:
            print("load RDN0")
            n0   = np.load(self.dir_p[:-3]+"/SAN0/"+self.rdn0fname%self.qe.upper())[:self.lmax+1]
        else:
            n0   = np.load(self.dir_p[:-3]+"/SAN0/"+self.san0fname%self.qe.upper())[:self.lmax+1,idx-1]
        kfilt = self.clkk/(self.clkk+n0)
        kfilt[0:self.lmin_p] = 0
        kfilt[self.lmax_p: ] = 0
        return kfilt

    def get_e_lmmask(self):
        if not hasattr(self, 'e_lmmask'):
            lmmask = get_lmmask(self.lmax, lmin=self.lmin_e, mmin=self.mmin_e, lmax_sub=self.lmax_e)
            self.e_lmmask = grid2alm(lmmask)
        return self.e_lmmask

    def get_btpl_alm(self,idx):
        fname = self.outdir+self.btpl_fname%idx
        if not os.path.isfile(fname):
            klm      = self.get_debiased_klm(idx)
            cinv_elm = self.get_cinv_elm(idx)

            kfilt   = self.get_kap_filt(idx)
            elmmask = self.get_e_lmmask()

            pwf  = hp.almxfl(klm, kfilt * safe_inv(self.phi2kap(self.ls)))
            ewf  = hp.almxfl(cinv_elm, self.clee) * elmmask

            qe      = qest.qest(self.qeconfig, self.qecls)
            _, blm  = qe.eval('bEP', ewf, pwf)
            hp.write_alm(fname, blm)
        else:
            blm = hp.read_alm(fname, hdu=1)
        return blm


    def get_bmap_in(self,idx):

        cmbdir="/oak/stanford/orgs/kipac/users/yukanaka/lensing19-20/inputcmb/tqu1/len/lmax5000/"
        fname="lensed_planck2018_base_plikHM_TTTEEE_lowl_lowE_lensing_cambphiG_teb1_seed%i_lmax17000_nside8192_interp1.6_method1_pol_1_alms_lowpass5000.fits"%idx

        blm  = hp.read_alm(cmbdir+fname, hdu=[3])
        bmap = hp.alm2map(blm, self.nside, lmax=5000)

        return bmap

    def tp2rd(self, tht, phi):
        ra=phi/np.pi*180.0
        dec=((tht*-1)+np.pi/2.0)/np.pi*180.
        return ra,dec

    def rd2tp(self, ra, dec):
        tht = (-dec+90.0)/180.0*np.pi
        phi = ra/180.0*np.pi
        return tht,phi

    def get_masked_spec(self, idx):
        # get non-BK purified spec
        fname = self.outdir+self.btpl_spec_fname%idx
        if not os.path.isfile(fname):
            mask = hp.read_map(self.maskfname)
            fsky = np.sum(mask**2)/mask.size

            btpl_lm  = self.get_btpl_alm(idx)
            btpl_map = hp.alm2map(btpl_lm, self.nside, lmax=self.lmax_b)
            auto     = hp.anafast(btpl_map * mask)/fsky
            cross = auto_in = None

            if idx != 0:
                if idx <= 250:
                    bmap_in  = self.get_bmap_in(idx)
                elif idx <= 500:
                    # https://github.com/SouthPoleTelescope/spt3g_software/blob/511f58f03a0a3e53f06f0ebd5d2df31bd6a33743/scratch/yomori/utils/utils.py#L248
                    bmap_full  = self.get_bmap_in(idx-250)
                    pix = np.where(mask > 0)[0] # patch 1 pixel list
                    tht,phi = hp.pix2ang(self.nside,pix)
                    tht2,phi2 = tht,phi+np.pi
                    ra,dec = self.tp2rd(tht2,phi2) # rotate 180
                    tht4,phi4 = self.rd2tp(ra,-1*dec) # flip
                    pix_antipode = hp.ang2pix(self.nside,tht4,phi4)
                    bmap_in = np.zeros_like(bmap_full)
                    bmap_in[pix] = bmap_full[pix_antipode] # full-sky map whose values over patch 1 are the values from patch 2
                    bmap_in *= -1
                cross    = hp.anafast(btpl_map * mask, bmap_in * mask)/fsky
                auto_in  = hp.anafast(bmap_in * mask)/fsky

            np.savez(fname, auto=auto, cross=cross, auto_in=auto_in)
        else:
            tmp   = np.load(fname)
            auto  = tmp['auto']
            cross = auto_in = None
            if idx != 0:
                cross = tmp['cross']
                auto_in  = tmp['auto_in']
        return auto, cross, auto_in

    def get_pure_masked_spec(self, idx, w=None, dl=True):
        # package/save both the raw and binned spectra for later processing
        # return saved raw and binned spectra
        fname = self.outdir+self.btpl_pure_spec_fname%idx
        if not os.path.isfile(fname):
            f       = h5py.File(self.puremask, "r")
            mask    = np.nan_to_num(f['w'][0][:])
            fsky    = np.sum( mask**2 ) / len(mask)

            #load lensing template (go from 2048 to 512 to apply obsmat)
            qltmap, ultmap = self.get_btpl_qumaps(idx, nside=512, iau=True)

            #get bicep-observed lensing template
            bo_qlt, bo_ult = self.get_b3obs_map(idx, qltmap, ultmap)

            #get purified lensing template
            QpB_lt, UpB_lt = self.get_purif_map(idx, bo_qlt, bo_ult)
            QpB_lt  = np.nan_to_num(QpB_lt)
            UpB_lt  = np.nan_to_num(UpB_lt)

            #now make auto/cross spec; -1*U to convert from IAU to COSMO
            alms_lt = hp.map2alm( [ np.zeros_like(mask), QpB_lt*mask, -1*UpB_lt*mask ])
            cls_lt  = hp.alm2cl(alms_lt)/fsky
            cls_in  = cls_x = None

            if w is None:
                w = np.ones_like(cls_lt[2])

            dbs_lt, lb = self.bin_cl(cls_lt[2], w=w, dl=dl)
            dbs_in  = dbs_x = None

            if idx != 0:
                #same for LCDM maps
                q_in, u_in      = self.get_b_in_qumaps(idx, nside=512, iau=True)
                bo_qin, bo_uin  = self.get_b3obs_map(idx, q_in, u_in)
                QpB_in, UpB_in  = self.get_purif_map(idx, bo_qin, bo_uin)
                QpB_in  = np.nan_to_num(QpB_in)
                UpB_in  = np.nan_to_num(UpB_in)

                #now make auto/cross spec; -1*U to convert from IAU to COSMO
                alms_in = hp.map2alm( [ np.zeros_like(mask), QpB_in*mask, -1*UpB_in*mask ])

                cls_in  = hp.alm2cl(alms_in)/fsky
                cls_x   = hp.alm2cl(alms_lt, alms_in)/fsky

                dbs_in, _ = self.bin_cl(cls_in[2], w=w, dl=dl)
                dbs_x , _ = self.bin_cl(cls_x[2],  w=w, dl=dl)


            #save the Cls [all TT/EE/BB..] and the binned Dls (Dbs; just BB)
            np.savez(fname, cls_lt=cls_lt, cls_x=cls_x, cls_in=cls_in,
                            dbs_lt=dbs_lt, dbs_x=dbs_x, dbs_in=dbs_in,
                            w=w, dl=dl, lb=lb)

        return  np.load(fname)

    def bin_cl(self, spec, w=None, dl=True):
        # BICEP bin definition
        #   case 'bicep_norm'
        #   r=1;
        #   n=35/r; be=20:n:581;  be=[linspace(0,be(1),r+1),be(2:end)];
        #
        #   w is weight in ell space (default 1)
        #   default output in dl = l*(l+1)/2pi Cl
        #   (match BPWF expectation)
        #
        # BK binning code:
        # nbin=length(be)-1;
        # Db = zeros(nbin,1);
        # for i=1:nbin
        # ind=find(l>=be(i)&l<=be(i+1));
        # Db(i)=nansum(Dl(ind))./nansum(w(ind));
        # bincenter(i)=mean(be(i:(i+1)));
        # end
        #

        #binedges
        be = np.arange(20, 581, 35)
        be = np.concatenate([[0], be])

        ell = np.arange(len(spec))
        if w is None:
            w = np.ones_like(spec)

        if dl:
            spec1 = ell*(ell+1)/2/np.pi * spec

        spec_binned = np.array( [ np.nansum(spec1[be[i]:be[i+1]+1]) / np.nansum(w[be[i]:be[i+1]+1]) for i in range(len(be)-1) ] )
        bincenter   = np.array( [ np.mean(be[i:i+2]) for i in range(len(be)-1) ] )

        return spec_binned, bincenter

    def get_btpl_qumaps(self,idx, nside=None, iau=True): #, maskfname=None):
        # return QU maps of b template at desired nside
        # for applying BK observing matrix (which goes from nside=512 to nside=256)
        # mask has to match nside (apply mask after applying obsmat; closer to what's done in analysis)

        # for BK obs mat; the QU maps needs to be in IAU convention

        #if maskfname==None:
        #    mask = hp.read_map(self.maskfname)
        #else:
        #    mask = hp.read_map(maskfname)

        btpl_lm  = self.get_btpl_alm(idx)

        if nside == None:
            nside  = self.nside
            lmax_b = self.lmax_b
        else:
            lmax_b = 2*nside
            btpl_lm = hutils.reduce_lmax(btpl_lm, lmax = lmax_b)
            b3bl= load_b3_beam()
            btpl_lm = hp.almxfl(btpl_lm, b3bl)

        zeroslm = np.zeros_like(btpl_lm)
        _, qmap, umap = hp.alm2map([zeroslm, zeroslm, btpl_lm], nside, lmax=lmax_b)

        if iau:
            return qmap, -1*umap
        else:
            return qmap, umap

    def get_b_in_qumaps(self, idx, nside=512, iau=True):
        # return QU maps of input B map at desired nside
        # for applying BK observating matrix (from nside=512 to nside=256)
        # the ouput should have the b3spt mask applied before hitting with purification matrix (?); no it        #  doesn't

        cmbdir="/lcrc/project/SPT3G/users/ac.yomori/sims/planck2018_cmb_v2/len/"
        fname="lensed_planck2018_base_plikHM_TTTEEE_lowl_lowE_lensing_cambphiG_teb1_seed%i_lmax17000_nside8192_interp1.6_method1_pol_1_alms_lowpass5000.fits"%idx

        blm  = hp.read_alm(cmbdir+fname, hdu=[3])

        if nside == None:
            nside  = self.nside
            lmax_b = 5000
        else:
            lmax_b = 2*nside
            b3bl= load_b3_beam()
            blm = hutils.reduce_lmax(blm, lmax = lmax_b)
            blm = hp.almxfl(blm, b3bl)

        zeroslm = np.zeros_like(blm)
        _, qmap, umap = hp.alm2map([zeroslm, zeroslm, blm], nside, lmax=lmax_b)

        if iau:
            return qmap, -1*umap
        else:
            return qmap, umap

    def get_comsep_qumaps(self, idx):
        # the compsep maps are in IAU, uK, and beam-smoothed by 20'
        # to prep it for applying obsmat, need to rebeam by b3beam/20'beam

        csmap = sio.loadmat(self.cmpsep_map%idx)

        #nside 512 Qmap in uK
        qmap = csmap['map']['Q'][0][0].flatten()
        umap = csmap['map']['U'][0][0].flatten()

        return

    def get_b3obs_map(self, idx, qlt_map, ult_map):
        #apply b3 obs mat on lensing template (LCDM input maps)
        #obsmat brings 512 maps (only observed pixels) to 256 maps (full sky)


        def hdf5_to_sparse(x):
            return sparse_csc_to_bcoo(x['data'],x['ir'],x['jc'],(x.attrs['MATLAB_sparse'],len(x['jc'])-1))

        def sparse_csc_to_bcoo(data,ir,jc,shape):
            return BCOO.from_scipy_sparse(csc_array((data,ir,jc),shape=shape).tocoo())

        def save_inv(x):  #safe inverse; on the weight matrix
            xout = np.zeros_like(x)
            xout[x != 0] = 1/(x[x !=0])
            return xout

        f=h5py.File(self.obsmatfname%idx,'r')
        R=hdf5_to_sparse(f['R'])

        #non-zero hit of B3 in nside=512
        b3hit_idx = np.where(f['obspix/col'])[1]

        stack_cutqumap = np.concatenate([qlt_map[b3hit_idx], ult_map[b3hit_idx]])

        invW    = save_inv(f['W'][0])

        b3obs_qumap = R@stack_cutqumap * invW
        b3obs_qlt   = b3obs_qumap[:len(b3obs_qumap)//2]
        b3obs_ult   = b3obs_qumap[len(b3obs_qumap)//2:]

        return b3obs_qlt, b3obs_ult

    def get_purif_map(self, idx, b3o_qlt, b3o_ult):
        # get purified Q/U maps (matching mode content as BK maps with filtering)
        # (even though neither LT nor LCDM maps need purifying.)
        #
        # b3o_qlt/ult are unmodified outputs from get_b3obs_map()
        #
        # output maps will need to be apodized/masked before taking PS

        g=h5py.File(self.purmatfname%idx, 'r')

        #apply 1/Qvar and 1/Uvar to unweighted maps
        inmap=np.hstack([b3o_qlt/g['projmatopt/reob/Qvar'][:][0],b3o_ult/g['projmatopt/reob/Uvar'][:][0]])

        #reduce to only observed pixels (expected size 61840)
        obspix = (g['projmatopt/obs_pixels'][:].T[0]-1).astype(int) #-1 because these are matlab indices
        inmap=inmap[obspix]

        #load purification matrix; put purified array in nside256*2 array
        pb=g['pb'][:,:].T  #shape = (61840, 5500)
        outmap=np.zeros(np.shape(g['projmatopt/reob/Qvar'])[1]*2)
        outmap[obspix]=pb @ (inmap @ pb).T

        N=len(outmap)

        QprojB=outmap[:N//2]*g['projmatopt/reob/Qvar'][:][0]
        UprojB=outmap[N//2:]*g['projmatopt/reob/Uvar'][:][0]

        return QprojB, UprojB




